# 课堂笔记

## 第 1 章  计算机图形学入门

+ 计算机图形硬件

  + 输出设备
  + 输入设备
  + 处理设备

+ 图形适配卡：显卡

  图形处理芯片：GPU

  通用图形处理器：GPGPU

+ fragment ~ pixel 【这两者真的是同一个概念吗】

+ 图形 API

  + OpenGL - 跨平台
  + DirectX - Microsoft

+ 引擎调用 API

+ 采样 - 光栅化

+ VBO 数据：位置坐标，法向量，RGB，纹理坐标

+ 计算机图形学

  + 生成图形
  + 处理图形
  + 显示图形

### 疑问

+ **fragment 和 pixel 是同一个概念吗？**

  之前在学习的时候对 fragment 只有一个大概的认识，可以理解为对顶点构成的图元的采样，但是不清楚采样的粒度是否是像素大小，后来在教程上看到这么一句话：

  > OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。
  >
  > 片段着色器的主要目的是计算一个像素的最终颜色。

  确实，片段的大小是像素级别的。

+ **为什么 OpenGL 主要处理三角形？**

  上课的时候经常听到老师说物体表面的**顶点**，当时就在想为什么不直接说物体表面的**点**，后来在教程上看到说：

  > OpenGL 主要处理三角形。

  的确，如果物体表面是由一个个小三角形构成的，说是顶点就合情合理了，但是为什么 OpenGL 主要处理三角形呢，我就去 reference 上查到了 `glDrawArrays` 的函数原型：

  ```c++
  void glDrawArrays(GLenum mode, GLint first, GLsizei count);
  ```

  其中第一个参数 `mode` 用来指定要绘制的图元类型，可取的值主要有 `GL_POINTS`, `GL_LINES`, `GL_TRIANGLES` 等等，但是没有看到矩形，我就在想为什么 `glDrawArrays` 不能直接绘制矩形呢，确实可以通过绘制两个三角形再拼接的方式间接地造出一个矩形，甚至还提供了 EBO 的方法来减少顶点个数，但是直接提供一个绘制矩形的方法不是更方便吗。

  后来我想到老师有说过为什么三角形稳定，因为只有三个顶点的时候能保证它们是**共面**的，我一下就明白了，我之前一直假设用来绘制矩形的四个顶点是共面的，所以意识不到它的麻烦之处，但是如果它们不共面的话，在片段着色器中进行纹理采样，颜色插值甚至用法向量计算光照都将成为很麻烦的问题，比如在 VBO 中指定法向量时，四个不共面的顶点中任意一点理论上都可以属于三个面，那法向量该如何指定就十分麻烦了。

  所以，在可以使用 EBO 的情况下，通过指定四个顶点直接绘制矩形显得没有必要，因为后者唯一的优势即减少顶点个数对于 EBO 来说也十分容易做到，但是非平面的复杂性以及对设计理念的违背是十分令人讨厌的。

## 第 2 章  光栅化技术

### 2-1 基本图元绘制算法

+ 图形的表示：线框模型、表面模型、实体模型
+ 图形的显示：窗口（window）和视区（viewport）的区别
+ 帧缓冲存储器：24 个位平面 - 全彩色；32 个位平面 - 真彩色（存储 α 值，像素点的不透明度）
+ 绘制基本图元：在 `glBegin()` 指定要绘制的图元类型，根据与 `glEnd()` 之间的顶点顺序进行绘制。
+ 光栅化（扫描线算法）：将基本图元的几何定义转化为图像空间中的像素点的集合（片段）
+ 点的光栅化：直接取整、四舍五入
+ 直线的光栅化：直线方程、DDA 算法、Bresenham 算法
+ 圆的光栅化：Bresenham 算法、中点画圆算法

### 2-2 多边形颜色填充与可见面判别

+ 多边形填充算法：内部检查法、奇偶扫描转换算法、有序边表多边形扫描转换算法、边填充算法、边标志算法、种子填充法、泛滥填充算法、渐变填充算法

+ 可见面判别算法：分为物空间算法和像空间算法

  画家算法、后相面判别算法（面剔除）、深度缓冲器算法（z-buffer）

### 2-3 反走样技术

+ 走样（aliasing）：由于低频采样（采样不充分）而造成的信息失真称为走样

  只要有像素存在，必然存在走样。

+ Nyquist 采样定理：为了能从采样信号中正确重建原始信号，采样频率必须大于或等于原始信号最大频率的**两倍**。

+ 滤波：箱式滤波、三角滤波、正弦滤波。

  滤波器的面积始终为 1。

+ 简单区域采样：像素的亮度与其落在直线条内的面积成正比

+ 全屏反走样技术（FSAA）：通过密集采样和滤波减少锯齿效应，主要针对 3D 场景绘制

+ 顺序栅格超采样（OGSS），旋转栅格超采样（RGSS）：采样点的位置旋转了一个角度来达成更好的消除锯齿目的。

+ 多级采样技术（MSAA）：超采样的优化，与相邻像素关联，选择边缘像素进行处理

+ 现有问题：性能下降，近 45 度和 135 度的边界走样。

+ 纹理放大滤波、纹理缩小滤波

+ OpenGL 反走样步骤：激活反走样 -> 激活融合操作 -> 选择反走样控制方式

+ 调用 `glHint()` 函数指定反走样执行方式：

  ```c++
  void glHint(GLenum target, GLenum hint);
  ```


### 疑问

+ **窗口和视口的区别是什么？**

  视口是与设备相关的一个矩形区域，坐标单位是与设备相关的。窗口的坐标是逻辑坐标，与设备无关。

  为了体会窗口坐标与视口坐标的转换，先用 `SetwindowtOrg(100, -300)` 将视口移到 (100,-300)，这相当于把逻辑点 (100,-300) 映射到设备点 (0,0）。

  进行画图时，它的转换过程如下： 
  窗口与视口坐标转换，由于窗口坐标 (100,-300) 映射为设备坐标 (0,0)，所以窗口 (100,-600) 映射为视口(0,-300)，窗口 (100,-800) 视映射为视口 (0,-500) 。

  程序作图时，使用的坐标总是是窗口坐标。