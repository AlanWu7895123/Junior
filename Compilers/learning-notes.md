# 编译原理学习笔记

## 第 1 章  绪论

+ **直线式程序** (straight-line program) 语言：有语句和表达式，但是没有循环和 if 语句，比如：

  ```
  Stm -> id := Exp
  ```

+ 表达式序列 `(s,e)` 的行为类似于 C 语言中的逗号操作符，在计算表达式 `e` 之前先计算语句 `s` 的**副作用**。所以 `s` 中的赋值操作有可能会影响 `e` 的结果。

### Lab 1: Straight-line Program Interpreter

+ `.h` 文件中最好不要写函数的实现，因为实现的代码有可能会调用别的类的方法，而在头文件中只有别的类的方法的定义而没有实现，会报错。

  因为是在 `.cpp` 文件中引用 `.h` 文件，编译时刻 `.h` 文件找不到 `.cpp` 文件。

+ `std::cout` 需要引入 `<iostream>` 库。

+ 报错 `'nullptr' was not declared in this scope` 有可能是 CMake 版本过低。

+ 在以 `a->f(x)` 这样的方式调用函数并返回 `x` 时，需要小心 `x` 是否改变，如果没变，极有可能应该写成

   `new_x=a->f(x)` ，然后返回新的 `new_x`。

+ 如果有这样的写法：

  ```c++
  a = f()->a;
  b = f()->b;
  ```

  最好能写成：

  ```c++
  sometype *tmp = f();
  a = tmp->a;
  b = tmp->b;
  ```

  避免执行两次 `f` 带来预料之外的错误。

## 第 2 章  词法分析

+ 两条重要的消除二义性的规则：最长匹配，规则优先。

### 正则表达式 => NFA

五种基本转换：

+ for ε
+ for input a
+ for AB
+ for A | B
+ for A*

### NFA => DFA

+ 先确定 DFA 的 start state：NFA 的 start state + 从该 start state 出发经过 ε 可到达的 state。
+ 在确定 DFA 的其他 state：从 DFA 的 start state 群中任一 state 出发，经过某 transition 和任意数量的 ε 可到达的 state。

### 用 ㅣ，ㅜ，ㅗ 做词法分析

+ ㅣ 表示当前 lexeme 的起始位置
+ ㅜ 表示遇到的最后一个 final state 的位置
+ ㅗ 表示当前扫描到的位置

开始新一轮扫描后，ㅣ不变，ㅜ，ㅗ 往前扫描，遇到 final state，ㅜ 停下，ㅗ 继续往前扫描，再遇到 final state，更新 ㅜ 位置，ㅗ 继续往前扫描，直到在状态机图中走不通为止，将ㅣ，ㅗ 都置于 ㅜ 所在的位置。

### Lab 2: Lexical Analysis

+ ctrl + A （^A）对应的 ascii 码是 1，^B 是 2，以此类推。
+ atoi 的参数的第一个字符似乎要求是数字或者正负号，不然会转换失败，至少第一个字符是 `\` 不行。
+ `"{digit}"` 匹配由这七个字符本身构成的字符串，`{digit}` 匹配 0 ~ 9 （如果前面定义了的话）

## 第 3 章  语法分析

+ 终结符（terminal）：该语言字母表中的单词

  非终结符（nonterminal）：出现在产生式左侧的符号

### 预测分析

+ 递归下降：将每一个产生式转变成递归函数中 switch 下的一个 case 子句。

  递归下降分析也称为预测分析，它只适合于每个产生式右侧的第一个 terminal 能够为产生式的选择提供足够信息的那种文法。

+ 确定 FIRST 和 FOLLOW 集合的方法：

  1. 首先确定每个非终结符是否 nullable。
  2. 然后确定每个非终结符的 FIRST 集合，这一步需要用到 nullable 信息。
  3. 最后确定每个非终结符的 FOLLOW 集合，这一步需要用到 nullable 和 FIRST集合的信息。

  （确定 FIRST 和 FOLLOW 集合的时候可以针对每个终结符来判断，即该终结符是不是属于某个集合，这样条理更清楚一些）

  这种方法和书上不一样。书上的方法是一遍一遍扫文法，每一遍都扩充集合直到集合不再变化，这种算法更适合程序实现，手工求的时候太费时间；而上述方法中每一步做完相应的 nullable 或者集合在之后就不会再改变，而且每一步更加灵活，适合手工求集合。

+ 利用 FIRST 和 FOLLOW 集合构造预测分析表，若表中不含多重定义的项，则称该文法为 LL(1) 文法，即从左至右分析、最左推导和超前查看一个符号。

+ 若预测分析表中含有多重定义的项，可以有两种方法来解决：

  + 消除左递归

    考虑这么两个产生式：`E->E+T` 以及 `E->T` ，当遇到一个 `T` 时，无法确定选择哪个产生式，所以引入一个新的非终结符 `E'` ，并将产生式重写为 `E->TE'`, `E'->+TE'`, `E'->ε` 。

  + 提取左因子

    考虑这么两个产生式：`S->if E then S else S` 以及 `S->if E then S`，当遇到一个 `if` 时，无法确定选择哪个产生式，所以引入一个新的非终结符 `X`，并将产生式重写为 `S->if E then S X`, `X->else S`, `X->ε`。

### LR 分析

#### LR(0) 分析

分析步骤：

1. 从初始状态开始，对每一个状态的每一项，利用 Goto 找到下一个状态，画出 DFA
2. 根据 DFA 画出分析表：
   + 圆点位于产生式末尾：放置规约动作
   + 圆点位于终结符左边：放置移进动作
   + 圆点位于非终结符左边：放置转换动作

#### SLR 分析

和 LR(0) 分析的不同之处在于：

+ LR(0) 分析中，只要某一状态中有一项圆点位于产生式结尾，就在分析表中这一个状态的那一行全部放置规约动作
+ SLR 分析中，不仅要圆点位于产生式结尾，还要超前查看的符号属于产生式左部非终结符的 FOLLOW 集合，才会在由这一个状态的那一行和这一个超前查看符号的那一列确定的位置放置规约动作。

#### LR(1) 分析

和 SLR 分析的不同之处在于，确定在哪一个位置放置归约动作不再靠检查超前查看符号是否属于 FOLLOW 集合，而是对于每一个状态每一项，都记录一组符号，当超前查看符号是这一组中的某个符号时，放置归约动作。

#### LALR(1) 分析

和 LR(1) 分析的不同之处在于，LALR(1) 分析忽略了记录的那一组符号，即如果在不看那一组符号而只看产生式的情况下，两个状态中的所有项都相同，则认为它们是同一个状态，将它们合并，这样可以得到一个较小的分析表。

### 分析器的生成器：Yacc

#### 冲突

默认情况下，Yacc 选择移进来解决移进 - 规约冲突，选择使用在文法中先出现的规则来解决规约 - 规约冲突。

#### 优先级指导

当遇到移进 - 规约冲突时，在移进一个**单词**和用一个**规则**进行规约之间存在选择，利用 Yacc 的优先级指导命令可以避免重写文法。

+ 单词的优先级为它们在声明时出现的顺序，越往下优先级越高。
+ 规则的优先级为规则右部最后出现的那个单词的优先级。（可用 %prec 赋予最高优先级）

定义好优先级后，我们便能判断到底是选择移进还是选择归约：

+ 当规则优先级较高时，选择归约；当单词优先级较高时，选择移进。
+ 当规则和单词优先级相等时（在同一行声明），如果它们由 %left 声明，选择归约；如果它们由 %right 声明，选择移进；如果它们由 %nonassoc 声明，产生一个错误。

#### 语法和语义

在语法分析阶段，不管是布尔表达式 be 还是算术表达式 ae 在文法中都应写成表达式 E，和语义有关的信息应该被推迟到语义处理阶段再解析。

### 错误恢复

#### 局部错误恢复：error 符号

遇到语法错误时，跳到下一个**同步单词**（比如右括号、分号），将同步单词前的错误部分作为 error 规约掉，然后继续分析。

#### 全局错误恢复：Burke-Fisher 错误恢复

在错误点之前 K 个单词的每一点，尝试用每一种可能的单词来进行插入、删除或替换。

该算法管理两个栈和一个队列：当前分析栈、旧分析栈和它们之间 K 个单词组成的队列。

+ 可以用 %value 命令指明插入每一种单词时使用的默认值。
+ 可以用 %change 命令给出关于首选尝试的建议。

## 第 4 章  抽象语法

+ Yacc 生成的语法分析器并行地维护着一个状态栈和一个语义值栈。
+ 为了记录单词在源程序中的位置，语法分析器应当同语义值栈一起维护着一个位置栈。Bison 能够做到这一点，但 Yacc 不能，一种解决方法是手动定义一个非终结符 pos，且 `pos->ε`。
+ Tiger 抽象语法中 pos 的选择可以根据个人的喜好。

##### Last-modified date: 2019.10.16, 7 p.m.