# 算法原理笔记

## 堆排序

建堆 + 排序

### 建堆

从最底层的非叶子节点开始整理堆，越靠上层的节点沉降时需要的最大比较次数越多，复杂度为 O(n)

### 排序

将堆顶元素移出，最后一个元素移至堆顶再沉降，如此循环，复杂度为 O(nlogn)

## Union-Find

### 线性表实现

+ `a[i]=v` 代表 i 号元素位于集合 v，初始状态：`a[i]=i`，即 n 个元素位于 n 个集合中
+ `find(i)` 寻找 i 号元素位于哪个集合，显然 i 号元素位于集合 a[i]  **时间复杂度：O(1)**
+ `union(Si, Sj)` 合并集合 i, j，对于所有 `a[k]=j`，set `a[k]=i`  **时间复杂度：O(n)**

### 树实现

+ `a[i]=v (v>=0)` 代表 i 号元素的父节点为 v 号元素

+ `a[i]=v (v<0)` 代表 i 号元素位于集合 i，且该集合中有 -v 个元素

  **i 号元素位于集合 i** 意味着集合 i 一直在主动合并别的集合（别的集合的树根插到自己的树根下），从未**被**合并过（自己集合的树根插到别的集合的树根下）。

+ `find(i)` 如果 a[i] < 0，则 i 号元素位于集合 i ；否则位于集合 find(a[i]) （向上查找）  **时间复杂度：O(n)**

+ `union(Si, Sj)` 令 a[i] = a[i] + a[j] （集合中元素个数增加，更新树根），a[j] = i（集合 j 被合并，不再有自己的树，将树根的值从原本集合中的元素个数更新为新集合的集合号）  **时间复杂度：O(1)**

### 树实现优化

+ `weightedUnion(Si, Sj)` 将小树合并到大树上，这样一来 find 操作的时间复杂度变成了**O(logn)**（可用数学归纳法证明）

### 树实现再优化：路径压缩

+ `colapsingFind(i)` 查找时遍历两遍查找路径，第一遍找树根，得到所在集合号；第二遍执行路径压缩，将路径上的所有节点直接连到树根，这样一来 find 操作的时间复杂度变成了**O(1)**。

  这里的 O(1) 是指在操作的数量超过一定阈值后，树的高度已经坍缩成 1（只有根节点和叶子节点两层），此时执行 find 操作的时间复杂度是 O(1)，而不像优化前，即使执行过再多次操作，树的高度不变，find 操作的时间复杂度一直是 O(logn)。

##### Last-modified date: 2019.10.8, 10 p.m.